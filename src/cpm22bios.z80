ft245: equ 8
ft245_status: equ 9
bell: equ 6
sd_data: equ 10
sd_status: equ 11

msize: equ 62

bias: equ (msize - 20) * 1024
ccp: equ $3400 + bias
bdos: equ ccp + $806
bios: equ ccp + $1600
cdisk: equ $0004
iobyte: equ $0003

nsects: equ ((bios - ccp) / 128)

.macro sd_set_cs
    ld a,%%1
    out (sd_status),a   ; set cs to 0
.endm

.phase bios

    jp boot
wboote:
    jp wboot
    jp const
    jp conin
    jp conout
    jp list
    jp punch
    jp reader
    jp home
    jp seldsk
    jp settrk
    jp setsec
    jp setdma
    jp read
    jp write
    jp listst
    jp sectran

boot:
    xor a
    ld (iobyte),a   ; set iobyte to 0
    ld (cdisk),a    ; set current disk to 0
    jp gocpm
wboot:
    ; need to read nsects sectors from disk into ccp
    ld sp,$80
    call init_sd_card
    ld c,0
    call seldsk     ; select drive A:
    call home       ; set track to 0
    ld b,nsects     ; set count to nsects
    ld c,0          ; set c to be track 0
    ld d,2          ; start on sector 2, to skip the potential boot sectors
    ld hl,ccp       ; set destination to ccp
load1:
    push bc         ; store count and track
    push de         ; store sector
    push hl         ; store destination
    ld c,d
    call setsec     ; set sector to the current one
    pop bc          ; get destination in bc
    push bc
    call setdma     ; set dma address so that data is loaded into right place
    call read       ; load data
    cp 0            ; check error code
    jp nz,wboot     ; if error, try again!
    pop hl          ; get destination again
    ld de,128       ; add 1 sector
    add hl,de
    pop de          ; pop sector
    pop bc          ; pop count and track
    dec b           ; decrement count
    jp z,gocpm      ; if all read, start cpm
    inc d           ; increment sector
    jp load1        ; load some more

gocpm:
    ld a,$c3        ; c3 is jp instr
    ld ($0000),a    ; store 'jp wboot' at 0
    ld hl,wboote
    ld ($0001),hl

    ld ($0005),a    ; store 'jp bdos' at 5
    ld hl,bdos
    ld ($0006),hl

    ld bc,$0080       ; set dma to $80
    call setdma

    ei              ; enable interrupts
    ld a,(cdisk)    ; load current disk
    ld c,a
    jp ccp          ; start the ccp

init_sd_card:
    sd_set_cs 0
    ld b,10
init:
    ld a,$ff
    call sd_write_a
    djnz init

    sd_set_cs 0

    ld hl,cmd0
    call sd_send_command
    ld (response),a

    sd_set_cs 1

    sd_set_cs 0

    ld hl,cmd8
    call sd_send_command
    ld (response),a

    ld b,4
    ld hl,response
    call sd_read_bytes

    sd_set_cs 1

    ; should check responses are correct, in proper sd card driver

send_acmd41:
    sd_set_cs 0
    ld hl,acmd
    call sd_send_command

    ld hl,acmd41
    call sd_send_command
    ld (response),a

    sd_set_cs 1

    ld a,(response)
    cp 0
    jp nz,send_acmd41

    sd_set_cs 0
    ld hl,cmd58
    call sd_send_command

    ld b,4
    ld hl,response
    call sd_read_bytes

    sd_set_cs 1
    ret

const:
    in a,(ft245_status)
    bit 0,a
    jp z,const_ready
    ld a,0
    ret
const_ready:
    ld a,$ff
    ret

conin:
    in a,(ft245_status)
    bit 0,a
    jp nz,conin
    in a,(ft245)
    res 7,a
    ret

conout:
    in a,(ft245_status)
    bit 1,a
    jp nz,conout
    ld a,c
    out (ft245),a
    ret

list:
    ret
punch:
    ret
reader:
    ret
    
home:
    ld bc,0
    ld (track),bc
    ret

seldsk:
    ld hl,0
    xor a       ; only one disk - return error if c isn't 0
    cp c
    ret nz

    ld hl,disk
    ld (hl),c
    ld hl,dpb_disk0
    ret

settrk:
    ld (track),bc
    ret

setsec:
    ld (sector),bc
    ret

setdma:
    ld (dma_addr),bc
    ret

read:
    ld bc,(sector)
    ld (cmd_read_block + 3),bc
    ld bc,(track)
    ld (cmd_read_block + 1),bc
    ; ld a,(disk)
    ; ld (cmd_read_block + 2),a

    sd_set_cs 2
    ld hl,cmd_read_block
    call sd_send_command
wait_for_data:
    ld a,$ff
    call sd_write_a
    in a,(sd_data)
    cp $fe
    jp nz,wait_for_data

    ld b,0
    ; ld hl,block0
    ld hl,buffer
    call sd_read_bytes
    ld b,0
    ; ld hl,block1
    ld hl,buffer + $100
    call sd_read_bytes

    sd_set_cs 3
    ld de,(dma_addr)
    ld bc,$80
    ld hl,buffer
    ldir

    ld a,0  ; error code - should really check!!

    ret
write:
    ld bc,(sector)
    ld (cmd_write_block + 3),bc
    ld bc,(track)
    ld (cmd_write_block + 1),bc
    ; ld a,(disk)
    ; ld (cmd_write_block + 2),a

    ld hl,(dma_addr)
    ld bc,$80
    ld de,buffer
    ldir

    sd_set_cs 2
    ld hl,cmd_write_block
    call sd_send_command

    ld a,$fe  ; start block token
    call sd_write_a

    ld b,0
    ld hl,buffer
    call sd_write_bytes

    ld b,0
    ld hl,buffer + $100
    call sd_write_bytes

    call sd_read_response
    ld (response),a

    sd_set_cs 3

    ld a,0

    ret
listst:
    ret

sectran:
    ld h,b
    ld l,c
    ret

disk: db 0
track: dw 0
sector dw 0
dma_addr: dw $0080

dpblk:
    dw $FFFF    ; sectors per track
    db 7        ; block shift factor
    db 127      ; block mask
    db 7        ; null mask
    dw $FFFF    ; disk size - 1
    dw $1000    ; directory max
    db $ff        ; alloc 0
    db $00        ; alloc 1
    dw 0        ; check size - number of dir entries to check to see
                ; if disk has changed. Treat this as a fixed disk for now.
    dw 1        ; track offset - first track has OS on it

dpb_disk0:
    dw $0000,$0000
    dw $0000,$0000
    dw dirbf,dpblk
    dw chk00,all00

response: db 0, 0, 0, 0, 0

cmd0:
    db $40,0,0,0,0,$95
cmd8:
    db $48,0,0,1,$AA,$87    ; 2.7-3.6V
acmd:
    db $77,0,0,0,0,$01   ; cmd55 - next command is and acmd
acmd41:
    db $69,$40,0,0,0,$01
cmd58:
    db $7A,0,0,0,0,$01


cmd_read_block:  ; read single block
    db $51,0,0,0,0,$01      ; needs a data address
cmd_write_block:  ; write single block
    db $58,0,0,0,0,$01

buffer: ds 512

sd_send_command:
.block
    ld b,6
send_loop:
    ld a,(hl)
    call sd_write_a
    inc hl
    djnz send_loop
    call sd_read_response
    ret
.endblock

sd_write_a:
    out (sd_data),a
    ; fall through to wait_for_ready
sd_wait_for_ready:
    in a,(sd_status)
    bit 2,a
    jp nz,sd_wait_for_ready
    ret

; b = number of bytes to read
; hl = address to store bytes
sd_read_bytes:
    ld a,$ff
    call sd_write_a
    in a,(sd_data)
    ld (hl),a
    inc hl
    djnz sd_read_bytes
    ret

; b = number of bytes to write
; hl = address of bytes to write
sd_write_bytes:
    ld a,(hl)
    call sd_write_a
    inc hl
    djnz sd_write_bytes
    ret

sd_read_response:
    ld a,$ff
    call sd_write_a
    in a,(sd_data)
    bit 7,a
    jp nz,sd_read_response
    ret

dirbf: ds 128
chk00: ds 16
all00: ds 31

end: