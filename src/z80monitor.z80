ft245: equ 8
ft245_status: equ 9
bell: equ 6

chr_cr: equ 13
chr_bs: equ 8
chr_lf: equ 10

bell_on: equ $ff
bell_off: equ 0

.phase 0
start:
    ld hl,boot_msg
    call write_line
loop:
    ld a, '!'
    call write_char
    call read_line
    ld hl,line
    call lookup_command
    push hl     ; swap hl and de
    push de
    pop hl
    pop de
    call call_hl
end_loop:
    jp loop

call_hl:
    jp (hl)

boot_msg: db 'Z80 Monitor\n', 0

; wait for output buffer to be not-full and write char in A to it
write_char:
.block
    push af
write_char1:
    in a,(ft245_status)
    bit 1,a
    jp nz,write_char1
    pop af
    out (ft245),a
    ret
.endblock

write_line:
    ld a,(hl)
    cp 0
    ret z
    call write_char
    inc hl
    jp write_line

read_line:
.block
    ld b,0ffh                   ; b is max line length
    ld hl,line                  ; hl is where the line will be stored
read_line_char:
    call read_char
    cp chr_lf
    jp z,got_eol
    cp chr_cr                   
    jp nz,check_bs              ; if key wasn't return or lf, check if it was backspace
got_eol:
    call write_char             ; echo the return just typed
    ld (hl),0                   ; store a terminating zero
    ret
check_bs:
    cp chr_bs
    jp z,got_backspace          ; if they pressed backspace go and handle it
    push af                     ; save a
    xor a ; ld a,0
    cp b                        ; if b is 0, the line buffer is full...
    jp z,read_line_sound_bell   ; so sound the bell
    pop af                      ; restore a
    call write_char             ; echo the typed character
    dec b                       ; decrement the remaining bytes available in buffer
    ld (hl),a                   ; store the typed character
    inc hl
    jp read_line_char           ; read another character
got_backspace:
    ld a,0ffh                   ; see if line buffer is empty...
    cp b
    jp z,read_line_sound_bell   ; ...and sound bell if it is
    ld a,chr_bs
    call write_char             ; echo the backspace
    inc b                       ; increment the remaining bytes available in buffer
    dec hl                      ; move line storage pointer back one
    jp read_line_char           ; read another character
read_line_sound_bell:
    call sound_bell
    jp read_line_char
.endblock

sound_bell:
    push bc                     ; set up loop variables
    ld bc,$0010
    ld a,bell_on
    out (bell),a                ; turn the bell on
sound_bell1:
    djnz sound_bell1            ; do the b loop
    dec c
    jp nz,sound_bell1           ; do the c loop
    ld a,bell_off
    out (bell),a                ; turn the bell off
    pop bc
    ret

; wait for a character to be available, and return it in A
read_char:
    ; don't really need to wait for char, but it's kind of
    ; nice for this to be non-blocking
    in a,(ft245_status)
    bit 0,a
    jp nz,read_char
    in a,(ft245)
    ret

line: ds 256

; pass in HL = address of the string to look up
; return DE = address of command to jump to
;        HL = address of next byte after matched string
lookup_command:
.block
    ld de,commands              ; load the start of the command table
compare_next_word:
    push hl                     ; store the address of the line we are matching
compare_next_letter:
    ld a,(de)                   ; get next letter
    ld b,a
    ld a,(hl)
    call to_upper
    cp b                        ; compare it with letter in command table
    jp nz,different
    inc de                      ; if they matched, move onto the next letter
    inc hl
    jp compare_next_letter
different:                      ; letters weren't the same, but after each command string
    bit 7,b                     ; there's a jump address with the high order bit set.
    jp z,find_jump              ; if it's not set, look for the next command
    ld a,' '                    ; now check we've found the end of the string
    cp (hl)                     ; look for a space first
    jp z,load_addr
    xor a ; ld a,0              ; then look for a null
    cp (hl)
    jp nz,found_jump            ; if the word wasn't found, skip to the next command
load_addr:
    pop bc
    push hl
    ld h,d                      ; load the address - MSB first
    ld l,e
    ld d,(hl)
    inc hl
    ld e,(hl)
    res 7,d                     ; reset the high order byte
    pop hl                      ; clear up the stack
    ret                         ; return with the command's jump address in de
find_jump:
    inc de                      ; skip through this command until we find the terminating
    ld a,(de)                   ; jump address
    bit 7,a
    jp z,find_jump
found_jump:
    inc de                      ; skip over the jump address
    inc de
    ld a,(de)                   ; check if next word is another jump
    bit 7,a                     ; if it is, we're at the end of the jump table
    jp nz,load_addr             ; load that address and use it.
    pop hl                      ; otherwise restore the original string's address
    jp compare_next_word        ; and try again
.endblock

; takes a byte in A and, if it's a-z, returns it in upper case
to_upper:
    cp 'a'
    ret c
    cp 'z' + 1
    ret nc
    sub 'a' - 'A'
    ret

rtc_ctrl_a: equ $2f
rtc_second: equ $20
rtc_minute: equ $21
rtc_hour: equ $22
rtc_day: equ $23
rtc_date: equ $24
rtc_month: equ $25
rtc_year: equ $26
rtc_century: equ $27

; A = 2 digit number in BCD
; returns HL = address of place to store number
bcd_to_num:
    push af
    and 0f0h
    srl a
    srl a
    srl a
    srl a
    add a,030h
    ld (hl),a
    inc hl
    pop af
    and 00fh
    add a,030h
    ld (hl),a
    ret

; HL = address of 2 digit number string
; returns A = BCD number
;         E = 0 - no error; 1 - error
;         D = binary number
;         HL = point to after the 2 digit string
num_to_bcd:
.block
    ld a,(hl)
    ld e,0
    sub $30
    jp c,error
    cp $0A
    jp nc,error
    ld d,a
    sla a
    sla a
    sla a
    push af
    add a,d
    add a,d
    ld d,a
    pop af
    sla a
    ld b,a
    inc hl
    ld a,(hl)
    sub $30
    jp c,error
    cp $0A
    jp nc,error
    push af
    add a,d
    ld d,a
    pop af
    add a,b
    inc hl
    ret
error:
    ld e,1
    ret
.endblock

print_time:
    ld a,001000000b ; TE=0, CS=1 (12.5pF crystal)
    out (rtc_ctrl_a),a

    in a,(rtc_hour)
    ld hl,timestr + 6
    call bcd_to_num

    in a,(rtc_minute)
    inc hl
    inc hl
    call bcd_to_num

    in a,(rtc_second)
    inc hl
    inc hl
    call bcd_to_num

    ld a,011000000b ; TE=1, CS=1 (12.5pF crystal)
    out (rtc_ctrl_a),a

    ld hl,timestr
    call write_line
    ret

print_date:
    ld a,001000000b ; TE=0, CS=1 (12.5pF crystal)
    out (rtc_ctrl_a),a

    in a,(rtc_century)
    ld hl,datestr + 6
    call bcd_to_num

    in a,(rtc_year)
    inc hl
    call bcd_to_num

    in a,(rtc_month)
    inc hl
    inc hl
    call bcd_to_num

    in a,(rtc_date)
    inc hl
    inc hl
    call bcd_to_num

    ld hl,datestr
    call write_line
    ret
    
; HL = string
; return HL = string after any skipped spaces
;        C = number of spaces skipped
skip_spaces:
.block
    ld c,0
    ld a,' '
next:
    cp (hl)
    ret nz
    inc hl
    inc c
    jp next
.endblock

timestr: db 'TIME: 00:00:00\n', 0
datestr: db 'DATE: 0000-00-00\n', 0

; store an address with MSB first, with bit 7 set to 1
.macro djump
    db (%%1 / $100) + $80
    db %%1 & $ff
.endm

cmd_help:
cmd_helpling:
    ld hl,help_msg
    jp write_line
help_msg: db 'Available commands: HELP PEEK POKE DUMP IN OUT JP CALL TIME SETTIME REG LOAD SAVE ROMWRITE\n', 0

cmd_time:
    call print_time
    jp print_date

cmd_settime:
    ld h,d
    ld l,e
    call skip_spaces
    xor a
    cp c
    jp z,no_time
    call parse_time
    xor a               ; check error code
    cp e
    ret nz

    ld a,001000000b ; TE=0, CS=1 (12.5pF crystal)
    out (rtc_ctrl_a),a

    ld hl,bcd_time
    ld a,(hl)
    out (rtc_hour),a
    inc hl
    ld a,(hl)
    out (rtc_minute),a
    inc hl
    ld a,(hl)
    out (rtc_second),a
    
    ld a,011000000b ; TE=1, CS=1 (12.5pF crystal)
    out (rtc_ctrl_a),a

    ld hl,time_set
    call write_line
    ret
time_set: db 'Time set\n', 0

; HL = address of time, in HH:MM:SS format (24 hour time)
; returns with bcd time at bcd_time
; writes error messages if there's an error
parse_time:
.block
hours:
    call num_to_bcd
    ld bc,bcd_time
    ld (bc),a
    xor a
    cp e
    jp nz,bad_time
    ld a,d
    cp 24
    jp nc,bad_time
    ld a,':'
    cp (hl)
    jp nz,bad_time
    inc hl

minutes:
    call num_to_bcd
    ld bc,bcd_time + 1
    ld (bc),a
    xor a
    cp e
    jp nz,bad_time
    ld a,d
    cp 60
    jp nc,bad_time
    ld a,':'
    cp (hl)
    jp nz,bad_time
    inc hl

seconds:
    call num_to_bcd
    ld bc,bcd_time + 2
    ld (bc),a
    xor a
    cp e
    jp nz,bad_time
    ld a,d
    cp 60
    jp nc,bad_time
done:
    xor a
    cp (hl)
    jp nz,bad_time
    ld e,0
    ret

    ; expect time in format HH:MM:SS
    ; give up if it doesn't match
    ; ignore trailing rubbish, for now
bad_time:
    ld hl,bad_time_msg
    call write_line
    ld e,1
    ret
bad_time_msg: db 'Invalid time specified\n', 0
no_time:
    ld hl,no_time_msg
    call write_line
    ld e,1
    ret
no_time_msg: db 'No time specified\n', 0
.endblock
bcd_time: db 'xxx'

; HL = address of 1-4 digits of hex, terminated with null, space or comma
; BC = number
;  E = error code
parse_hex:
.block
    ld bc,0
    ld d,4
parse_next:
    ld a,(hl)
    call to_upper
    cp '0'
    jp c,bad_hex
    cp '9' + 1
    jp nc,not_decimal
    sub '0'
    jp add_digit
not_decimal:
    cp 'A'
    jp c,bad_hex
    cp 'F' + 1
    jp nc,bad_hex
    sub 'A' - 10
add_digit:
    add a,c
    ld c,a
    ld a,b
    adc a,0
    ld b,a

    ld e,0
    inc hl
    xor a
    cp (hl)
    ret z
    ld a,' '
    cp (hl)
    ret z
    ld a,0x2C   ; comma - doesn't parse as ','
    cp (hl)
    ret z

    push hl
    ld h,b
    ld l,c
    add hl,hl
    add hl,hl
    add hl,hl
    add hl,hl
    ld b,h
    ld c,l
    pop hl
    
    dec d
    jp z,bad_hex

    jp parse_next

bad_hex:
    ld e,1
    ret
.endblock

; A = number
; HL = address to store formatted number at
format_hex_2:
.block
    ld d,2
    push af
    srl a
    srl a
    srl a    
    srl a
next_digit:
    cp 10
    jp c,num
    add a,'A' - '0' - 10
num:
    add a,'0'
    ld (hl),a
    inc hl
    pop af
    and $0f
    dec d
    push af
    jp nz,next_digit
    pop af
    ret
.endblock

cmd_peek:
.block
    ld h,d
    ld l,e
    call skip_spaces
    xor a
    cp c
    jp z,error
    call parse_hex
    xor a               ; check error code
    cp e
    jp nz,error

    ld a,(bc)
    ld hl,value
    call format_hex_2

    ld hl,value
    jp write_line
error:
    ld hl,error_msg
    jp write_line
error_msg: db 'Error\n',0
value: db '00\n',0
.endblock
    

cmd_poke:
cmd_dump:
cmd_in:
cmd_out:
cmd_jp:
cmd_call:
cmd_setdate:
cmd_reg:
cmd_load:
cmd_save:
cmd_romwrite:
    ld hl,not_implemented_msg
    jp write_line
not_implemented_msg: db 'Not implemented yet\n', 0

cmd_error:
    ld hl, unknown_command
    jp write_line
unknown_command: db 'Unknown command\n', 0
    ret

commands:
    db 'HELP'
    djump cmd_help
    db 'HELP!'
    djump cmd_helpling
    db 'PEEK'
    djump cmd_peek
    db 'POKE'
    djump cmd_poke
    db 'DUMP'
    djump cmd_dump
    db 'IN'
    djump cmd_in
    db 'OUT'
    djump cmd_out
    db 'JP'
    djump cmd_jp
    db 'CALL'
    djump cmd_call
    db 'TIME'
    djump cmd_time
    db 'SETTIME'
    djump cmd_settime
    db 'SETDATE'
    djump cmd_setdate
    db 'REG'
    djump cmd_reg
    db 'LOAD'
    djump cmd_load
    db 'SAVE'
    djump cmd_save
    db 'ROMWRITE'
    djump cmd_romwrite
    djump cmd_error

end:
.dephase