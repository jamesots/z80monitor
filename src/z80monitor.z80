ft245: equ 8
ft245_status: equ 9
bell: equ 6

chr_cr: equ 13
chr_bs: equ 8
chr_lf: equ 10

bell_on: equ $ff
bell_off: equ 0

.phase 0
start:
    ld hl,boot_msg
    call write_line
loop:
    ld a, '!'
    call write_char
    call read_line
    ld hl,line
    call lookup_command
    ld h,d
    ld l,e
    call call_hl
end_loop:
    jp loop

call_hl:
    jp (hl)

boot_msg: db 'Z80 Monitor\n', 0

; wait for output buffer to be not-full and write char in A to it
write_char:
    push af
write_char1:
    in a,(ft245_status)
    bit 1,a
    jp nz,write_char1
    pop af
    out (ft245),a
    ret

write_line:
    ld a,(hl)
    cp 0
    ret z
    call write_char
    inc hl
    jp write_line

read_line:
    ld b,0ffh                   ; b is max line length
    ld hl,line                  ; hl is where the line will be stored
read_line_char:
    call read_char
    cp chr_lf
    jp z,got_eol
    cp chr_cr                   
    jp nz,check_bs              ; if key wasn't return or lf, check if it was backspace
got_eol:
    call write_char             ; echo the return just typed
    ld (hl),0                   ; store a terminating zero
    ret
check_bs:
    cp chr_bs
    jp z,got_backspace          ; if they pressed backspace go and handle it
    push af                     ; save a
    xor a ; ld a,0
    cp b                        ; if b is 0, the line buffer is full...
    jp z,read_line_sound_bell   ; so sound the bell
    pop af                      ; restore a
    call write_char             ; echo the typed character
    dec b                       ; decrement the remaining bytes available in buffer
    ld (hl),a                   ; store the typed character
    inc hl
    jp read_line_char           ; read another character
got_backspace:
    ld a,0ffh                   ; see if line buffer is empty...
    cp b
    jp z,read_line_sound_bell   ; ...and sound bell if it is
    ld a,chr_bs
    call write_char             ; echo the backspace
    inc b                       ; increment the remaining bytes available in buffer
    dec hl                      ; move line storage pointer back one
    jp read_line_char           ; read another character
read_line_sound_bell:
    call sound_bell
    jp read_line_char

sound_bell:
    push bc                     ; set up loop variables
    ld bc,$0010
    ld a,bell_on
    out (bell),a                ; turn the bell on
sound_bell1:
    djnz sound_bell1            ; do the b loop
    dec c
    jp nz,sound_bell1           ; do the c loop
    ld a,bell_off
    out (bell),a                ; turn the bell off
    pop bc
    ret

; wait for a character to be available, and return it in A
read_char:
    ; don't really need to wait for char, but it's kind of
    ; nice for this to be non-blocking
    in a,(ft245_status)
    bit 0,a
    jp nz,read_char
    in a,(ft245)
    ret

line: ds 256

; pass in hl pointing to the string to find
lookup_command:
    ld de,commands              ; load the start of the command table
compare_next_word:
    push hl                     ; store the address of the line we are matching
compare_next_letter:
    ld a,(de)                   ; get next letter
    ld b,a
    ld a,(hl)
    call to_upper
    cp b                        ; compare it with letter in command table
    jp nz,different
    inc de                      ; if they matched, move onto the next letter
    inc hl
    jp compare_next_letter
different:                      ; letters weren't the same, but after each command string
    bit 7,b                     ; there's a jump address with the high order bit set.
    jp z,find_jump              ; if it's not set, look for the next command
    ld a,' '                    ; now check we've found the end of the string
    cp (hl)                     ; look for a space first
    jp z,load_addr
    xor a ; ld a,0              ; then look for a null
    cp (hl)
    jp nz,found_jump            ; if the word wasn't found, skip to the next command
load_addr:
    ld h,d                      ; load the address - MSB first
    ld l,e
    ld d,(hl)
    inc hl
    ld e,(hl)
    res 7,d                     ; reset the high order byte
    pop hl                      ; clear up the stack
    ret                         ; return with the command's jump address in de
find_jump:
    inc de                      ; skip through this command until we find the terminating
    ld a,(de)                   ; jump address
    bit 7,a
    jp z,find_jump
found_jump:
    inc de                      ; skip over the jump address
    inc de
    ld a,(de)                   ; check if next word is another jump
    bit 7,a                     ; if it is, we're at the end of the jump table
    jp nz,load_addr             ; load that address and use it.
    pop hl                      ; otherwise restore the original string's address
    jp compare_next_word        ; and try again

; takes a byte in A and, if it's a-z, returns it in upper case
to_upper:
    cp 'a'
    ret c
    cp 'z' + 1
    ret nc
    sub 'a' - 'A'
    ret

rtc_ctrl_a: equ $2f
rtc_seconds: equ $20
rtc_minutes: equ $21
rtc_hours: equ $22

print_time:
    ld a,001000000b ; TE=0, CS=1 (12.5pF crystal)
    out (rtc_ctrl_a),a

    in a,(rtc_seconds)
    and 0f0h
    srl a
    srl a
    srl a
    srl a
    add a,030h
    ld (timestr + 12),a
    in a,(rtc_seconds)
    and 00fh
    add a,030h
    ld (timestr + 13),a

    in a,(rtc_minutes)
    and 0f0h
    srl a
    srl a
    srl a
    srl a
    add a,030h
    ld (timestr + 9),a
    in a,(rtc_minutes)
    and 00fh
    add a,030h
    ld (timestr + 10),a

    in a,(rtc_hours)
    and 0f0h
    srl a
    srl a
    srl a
    srl a
    add a,030h
    ld (timestr + 6),a
    in a,(rtc_hours)
    and 00fh
    add a,030h
    ld (timestr + 7),a

    ld a,011000000b ; TE=1, CS=1 (12.5pF crystal)
    out (rtc_ctrl_a),a

    ld hl,timestr
    call write_line
    ret

timestr: db 'TIME: 00:00:00\n', 0

; store an address with MSB first, with bit 7 set to 1
.macro djump
    db (%%1 / $100) + $80
    db %%1 & $ff
.endm

cmd_help:
cmd_helpling:
    ld hl,help_msg
    jp write_line
help_msg: db 'Available commands: HELP PEEK POKE DUMP IN OUT JP CALL TIME SETTIME REG LOAD SAVE ROMWRITE\n', 0

cmd_time:
    jp print_time
    
cmd_peek:
cmd_poke:
cmd_dump:
cmd_in:
cmd_out:
cmd_jp:
cmd_call:
cmd_settime:
cmd_reg:
cmd_load:
cmd_save:
cmd_romwrite:
    ld hl,not_implemented_msg
    jp write_line
not_implemented_msg: db 'Not implemented yet\n', 0

cmd_error:
    ld hl, unknown_command
    jp write_line
unknown_command: db 'Unknown command\n', 0
    ret

commands:
    db 'HELP'
    djump cmd_help
    db 'HELP!'
    djump cmd_helpling
    db 'PEEK'
    djump cmd_peek
    db 'POKE'
    djump cmd_poke
    db 'DUMP'
    djump cmd_dump
    db 'IN'
    djump cmd_in
    db 'OUT'
    djump cmd_out
    db 'JP'
    djump cmd_jp
    db 'CALL'
    djump cmd_call
    db 'TIME'
    djump cmd_time
    db 'SETTIME'
    djump cmd_settime
    db 'REG'
    djump cmd_reg
    db 'LOAD'
    djump cmd_load
    db 'SAVE'
    djump cmd_save
    db 'ROMWRITE'
    djump cmd_romwrite
    djump cmd_error

end:
.dephase